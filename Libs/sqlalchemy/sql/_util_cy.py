# sql/_util_cy.py
# Copyright (C) 2010-2024 the SQLAlchemy authors and contributors
# <see AUTHORS file>
#
# This module is part of SQLAlchemy and is released under
# the MIT License: https://www.opensource.org/licenses/mit-license.php

from __future__ import annotations

from typing import Dict
from typing import Tuple
from typing import TYPE_CHECKING
from typing import Union

from ..util.typing import Literal

if TYPE_CHECKING:
    from .cache_key import CacheConst

# START GENERATED CYTHON IMPORT
# This section is automatically generated by the script tools/cython_imports.py
try:
    # NOTE: the cython compiler needs this "import cython" in the file, it
    # can't be only "from sqlalchemy.util import cython" with the fallback
    # in that module
    import cython
except ModuleNotFoundError:
    from sqlalchemy.util import cython


def _is_compiled() -> bool:
    """Utility function to indicate if this module is compiled or not."""
    return cython.compiled  # type: ignore[no-any-return]


# END GENERATED CYTHON IMPORT


@cython.cclass
class prefix_anon_map(Dict[str, str]):
    """A map that creates new keys for missing key access.

    Considers keys of the form "<ident> <name>" to produce
    new symbols "<name>_<index>", where "index" is an incrementing integer
    corresponding to <name>.

    Inlines the approach taken by :class:`sqlalchemy.util.PopulateDict` which
    is otherwise usually used for this type of operation.

    """

    def __missing__(self, key: str, /) -> str:
        derived: str
        value: str
        self_dict: dict = self  # type: ignore[type-arg]

        derived = key.split(" ", 1)[1]

        anonymous_counter: int = self_dict.get(derived, 1)
        self_dict[derived] = anonymous_counter + 1
        value = f"{derived}_{anonymous_counter}"
        self_dict[key] = value
        return value


@cython.cclass
class anon_map(
    Dict[
        Union[int, str, "Literal[CacheConst.NO_CACHE]"],
        Union[Literal[True], str],
    ]
):
    """A map that creates new keys for missing key access.

    Produces an incrementing sequence given a series of unique keys.

    This is similar to the compiler prefix_anon_map class although simpler.

    Inlines the approach taken by :class:`sqlalchemy.util.PopulateDict` which
    is otherwise usually used for this type of operation.

    """

    if cython.compiled:
        _index: cython.uint

        def __cinit__(self):  # type: ignore[no-untyped-def]
            self._index = 0

    else:
        _index: int = 0  # type: ignore[no-redef]

    def get_anon(self, obj: object, /) -> Tuple[str, bool]:
        self_dict: dict = self  # type: ignore[type-arg]

        idself = id(obj)
        if idself in self_dict:
            return self_dict[idself], True
        else:
            return self.__missing__(idself), False

    def __missing__(self, key: Union[int, str], /) -> str:
        val: str
        self_dict: dict = self  # type: ignore[type-arg]

        self_dict[key] = val = str(self._index)
        self._index += 1
        return val
